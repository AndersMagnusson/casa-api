// Code generated by go-swagger; DO NOT EDIT.
package restapi

import (
	"context"
	"crypto/tls"
	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/sirupsen/logrus"

	"github.com/boltdb/bolt"
	errors "github.com/go-openapi/errors"
	runtime "github.com/go-openapi/runtime"
	middleware "github.com/go-openapi/runtime/middleware"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	graceful "github.com/tylerb/graceful"

	"casa-api/grpc/casa/pkg/client"
	"casa-api/models"
	alarmsFunc "casa-api/pkg/alarms"
	alertsFunc "casa-api/pkg/alerts"
	"casa-api/pkg/database"
	devicesFunc "casa-api/pkg/devices"
	discoveryFunc "casa-api/pkg/discovery"
	"casa-api/pkg/logging"
	"casa-api/pkg/status"
	"casa-api/pkg/subscribers"
	"casa-api/restapi/operations"
	"casa-api/restapi/operations/alarms"
	"casa-api/restapi/operations/alerts"
	"casa-api/restapi/operations/devices"
	"casa-api/restapi/operations/discovery"
)

// This file is safe to edit. Once it exists it will not be overwritten

//go:generate swagger generate server --target .. --name MagnussonHomeSecurity --spec ..\swagger.yaml

var opts = &struct {
	Location string `long:"location" description:"default to localhost other option is cloud" default:"localhost"`
	Group    struct {
		Location bool `long:"location2"`
	} `group:"Grouped Options"`
}{}

func configureFlags(api *operations.CasaAPI) {
	// var opts = &struct {
	// 	Location string `long:"location" description:"default to localhost other option is cloud" default:"localhost"`
	// 	Group    struct {
	// 		Location bool `long:"location2"`
	// 	} `group:"Grouped Options"`
	// }{}
	location := swag.CommandLineOptionsGroup{ShortDescription: "Grouped Options", LongDescription: "", Options: opts}
	api.CommandLineOptionsGroups = []swag.CommandLineOptionsGroup{location}
}

func configureAPI(api *operations.CasaAPI) http.Handler {
	// configure the api here
	api.ServeError = errors.ServeError
	// Set your custom logger if needed. Default one is log.Printf
	// Expected interface func(string, ...interface{})
	//
	// Example:
	logging.Init()
	api.Logger = log.Printf

	api.JSONConsumer = runtime.JSONConsumer()
	api.JSONProducer = runtime.JSONProducer()
	fmt.Println(opts.Location)

	db, err := bolt.Open("casa.db", 0600, nil)
	if err != nil {
		log.Fatal(err)
	}
	database.SetDatabase(db)
	err = alertsFunc.CreateBucketIfNotExists()
	if err != nil {
		log.Fatal(err)
	}
	err = alarmsFunc.CreateBucketIfNotExists()
	if err != nil {
		log.Fatal(err)
	}
	err = devicesFunc.CreateBucketIfNotExists()
	if err != nil {
		log.Fatal(err)
	}
	logrus.Debug("Buckets created")

	subscribers.Enable()
	discoveryFunc.DiscoveryRoutine()
	devicesFunc.StartStatusRoutine(time.Minute * 20)

	if opts.Location == "cloud" {
		// start grpc server
		c := client.Client("127.0.0.1:6262", "password", "hubba")
		ctx := context.Background()
		err := c.Run(ctx)
		if err != nil {
			fmt.Println(err)
		}
	} else {
		// start grpcs client

	}
	// alerts
	api.AlertsAddAlertHandler = alerts.AddAlertHandlerFunc(func(params alerts.AddAlertParams) middleware.Responder {
		err := alertsFunc.HandleAlert(params.AlarmID, params.ID, *params.Body)
		if err != nil {
			logrus.Warnf("Failed update alert, %v, err: %s", params.Body, err.Error())
			return alerts.NewAddAlertDefault(500)
		}
		return alerts.NewAddAlertDefault(200)
	})

	api.AlertsListAlertsHandler = alerts.ListAlertsHandlerFunc(func(params alerts.ListAlertsParams) middleware.Responder {
		a, err := alertsFunc.GetAllLogs()

		if err != nil {
			logrus.Warnf("Failed to get alert log, err: %s", err.Error())
			return alerts.NewListAlertsDefault(500)
		}
		b := make([]*models.Alert, len(a))
		for index := 0; index < len(a); index++ {
			b[index] = &a[index]
		}
		return alerts.NewListAlertsOK().WithPayload(b)
	})

	api.AlertsListAlertsForAlarmHandler = alerts.ListAlertsForAlarmHandlerFunc(func(params alerts.ListAlertsForAlarmParams) middleware.Responder {
		a, err := alertsFunc.GetAllLogsForAlarm(params.AlarmID)

		if err != nil {
			logrus.Warnf("Failed to get alert log, err: %s", err.Error())
			return alerts.NewListAlertsForAlarmDefault(500)
		}
		b := make([]*models.Alert, len(a))
		for index := 0; index < len(a); index++ {
			b[index] = &a[index]
		}
		return alerts.NewListAlertsForAlarmOK().WithPayload(b)
	})

	api.AlertsListAlertsByIDHandler = alerts.ListAlertsByIDHandlerFunc(func(params alerts.ListAlertsByIDParams) middleware.Responder {
		a, err := alertsFunc.GetLogs(params.AlarmID, params.ID)
		if err != nil {
			logrus.Warnf("Failed to get alert log, err: %s", err.Error())
			return alerts.NewListAlertsByIDDefault(500)
		}
		if len(a) == 0 {
			return alerts.NewListAlertsByIDDefault(404)
		}
		b := make([]*models.Alert, len(a))
		for index := 0; index < len(a); index++ {
			b[index] = &a[index]
		}
		return alerts.NewListAlertsByIDOK().WithPayload(b)
	})

	// alarms
	api.AlarmsListAlarmsHandler = alarms.ListAlarmsHandlerFunc(func(params alarms.ListAlarmsParams) middleware.Responder {
		a, err := alarmsFunc.GetAlarms()
		if err != nil {
			logrus.Warnf("Failed to get alarms, err: %s", err.Error())
			return alarms.NewListAlarmsDefault(500)
		}
		b := make([]*models.Alarm, len(a))
		for index := 0; index < len(a); index++ {
			// b[index] = &a[index]
			b[index] = &a[index]
		}
		return alarms.NewListAlarmsOK().WithPayload(b)
	})

	api.AlarmsListAlarmLogsHandler = alarms.ListAlarmLogsHandlerFunc(func(params alarms.ListAlarmLogsParams) middleware.Responder {
		logs, err := alarmsFunc.GetLogs(params.ID)
		if err != nil {
			logrus.Warnf("Failed to get logs, err: %s", err.Error())
			return alarms.NewListAlarmsDefault(500)
		}
		res := make([]*models.ToggleAlarm, len(logs))
		for index := 0; index < len(logs); index++ {
			// b[index] = &a[index]
			res[index] = &logs[index]
		}
		return alarms.NewListAlarmLogsOK().WithPayload(res)
	})

	api.AlarmsGetAlarmHandler = alarms.GetAlarmHandlerFunc(func(params alarms.GetAlarmParams) middleware.Responder {
		a, err := alarmsFunc.GetAlarm(params.ID)
		if err != nil {
			logrus.Warnf("Failed to get alarm, err: %s", err.Error())
			return alarms.NewGetAlarmDefault(500)
		}
		if a.ID != params.ID {
			return alarms.NewGetAlarmDefault(404)
		}
		return alarms.NewGetAlarmOK().WithPayload(&a)
	})

	api.AlarmsDeleteAlarmHandler = alarms.DeleteAlarmHandlerFunc(func(params alarms.DeleteAlarmParams) middleware.Responder {
		var f = func(tx *bolt.Tx) error {
			err := alarmsFunc.DeleteAlarm(tx, params.ID)
			if err != nil {
				return err
			}
			err = alertsFunc.Delete(tx, params.ID)
			if err != nil {
				return err
			}
			return nil
		}
		err := database.Update(f)

		if err != nil {
			logrus.Warnf("Failed to delete alarm, err: %s", err.Error())
			return alarms.NewDeleteAlarmDefault(500)
		}
		return alarms.NewDeleteAlarmNoContent()
	})

	api.AlarmsToggleAlarmHandler = alarms.ToggleAlarmHandlerFunc(func(params alarms.ToggleAlarmParams) middleware.Responder {
		toggleAlarm, err := alarmsFunc.ToggleAlarm(params.ID, params.Body.On)
		if err != nil {
			logrus.Warnf("Failed to toggle alarm, err: %s", err.Error())
			return alarms.NewToggleAlarmDefault(500)
		}
		return alarms.NewToggleAlarmCreated().WithPayload(toggleAlarm)
	})

	api.AlarmsCreateAlarmHandler = alarms.CreateAlarmHandlerFunc(func(params alarms.CreateAlarmParams) middleware.Responder {
		if len(params.Body.ID) == 0 {
			return alarms.NewCreateAlarmDefault(400)
		}
		err := alarmsFunc.CreateAlarm(params.Body)
		if err != nil {
			logrus.Warnf("Failed to create alarm, err: %s", err.Error())
			return alarms.NewCreateAlarmDefault(500)
		}
		return alarms.NewCreateAlarmCreated()
	})

	// devices
	api.DevicesAddDeviceHandler = devices.AddDeviceHandlerFunc(func(params devices.AddDeviceParams) middleware.Responder {
		statusCode, _ := devicesFunc.Save(params.Body)
		if statusCode != 200 {
			return devices.NewAddDeviceDefault(statusCode)
		}
		return devices.NewAddDeviceOK()
	})

	api.DevicesListOfDevicesHandler = devices.ListOfDevicesHandlerFunc(func(params devices.ListOfDevicesParams) middleware.Responder {
		existingDevices, err := devicesFunc.List()
		if err != nil {
			return devices.NewListOfDevicesDefault(500)
		}

		result := make([]*models.Device, 0)
		for _, v := range existingDevices {
			status := &models.DeviceStatus{
				Credential:      v.Status.Credential,
				Network:         v.Status.Network,
				HasStatus:       v.Status.HasStatus,
				LastStatusCheck: strfmt.DateTime(v.Status.LastStatusCheck),
				Error:           v.Status.Error,
				Message:         v.Status.Message,
				StatusCode:      int64(v.Status.StatusCode),
			}
			result = append(result, &models.Device{Username: v.Username, SerialNumber: v.SerialNumber, Address: v.Address, Model: v.ModelName, Status: status})
		}

		return devices.NewListOfDevicesOK().WithPayload(result)
	})

	api.DevicesDeleteDeviceHandler = devices.DeleteDeviceHandlerFunc(func(params devices.DeleteDeviceParams) middleware.Responder {
		err := devicesFunc.Delete(params.ID)
		if err != nil {
			return devices.NewDeleteDeviceDefault(500)
		}
		return devices.NewDeleteDeviceOK()
	})

	// Discovery
	api.DiscoveryListDiscoveredCamerasHandler = discovery.ListDiscoveredCamerasHandlerFunc(func(params discovery.ListDiscoveredCamerasParams) middleware.Responder {
		discoveredDevices := discoveryFunc.GetDiscoveredDevices()
		result := make([]*models.DiscoveredDevice, 0, len(discoveredDevices))

		for _, value := range discoveredDevices {
			d := models.DiscoveredDevice{
				Address:        value.Address,
				SerialNumber:   value.SerialNumber,
				Model:          value.ModelName,
				ModelNumber:    value.ModelNumber,
				LastDiscovered: strfmt.DateTime(value.LastDiscovered),
			}
			status := status.GetStatus(d.SerialNumber)
			d.Status = &models.DeviceStatus{
				Credential:      status.Credential,
				Network:         status.Network,
				HasStatus:       status.HasStatus,
				LastStatusCheck: strfmt.DateTime(status.LastStatusCheck),
				Error:           status.Error,
				Message:         status.Message,
				StatusCode:      int64(status.StatusCode),
			}
			result = append(result, &d)
		}
		return discovery.NewListDiscoveredCamerasOK().WithPayload(result)
	})

	api.DiscoveryNewDiscoveryHandler = discovery.NewDiscoveryHandlerFunc(func(params discovery.NewDiscoveryParams) middleware.Responder {
		discoveryFunc.Start()
		return discovery.NewNewDiscoveryOK()
	})

	api.DiscoverySetDeviceCredentialsForDiscoveryHandler = discovery.SetDeviceCredentialsForDiscoveryHandlerFunc(func(params discovery.SetDeviceCredentialsForDiscoveryParams) middleware.Responder {
		statusCode, _ := discoveryFunc.SetCredential(params.SerialNumber, params.Body.Username, params.Body.Password)
		if statusCode > 0 {
			return discovery.NewSetDeviceCredentialsForDiscoveryDefault(statusCode)
		}
		return discovery.NewSetDeviceCredentialsForDiscoveryDefault(500)
	})

	api.ServerShutdown = func() {
		db.Close()
	}

	logrus.Info("Starting the server")
	return setupGlobalMiddleware(api.Serve(setupMiddlewares))
}

// The TLS configuration before HTTPS server starts.
func configureTLS(tlsConfig *tls.Config) {
	// Make all necessary changes to the TLS configuration here.
}

// As soon as server is initialized but not run yet, this function will be called.
// If you need to modify a config, store server instance to stop it individually later, this is the place.
// This function can be called multiple times, depending on the number of serving schemes.
// scheme value will be set accordingly: "http", "https" or "unix"
func configureServer(s *graceful.Server, scheme, addr string) {
}

// The middleware configuration is for the handler executors. These do not apply to the swagger.json document.
// The middleware executes after routing but before authentication, binding and validation
func setupMiddlewares(handler http.Handler) http.Handler {
	return handler
}

// The middleware configuration happens before anything, this middleware also applies to serving the swagger.json document.
// So this is a good place to plug in a panic handling middleware, logging and metrics
func setupGlobalMiddleware(next http.Handler) http.Handler {
	return Web(opts.Location)(next)
}
